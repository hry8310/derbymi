/*

   Derby - Class org.apache.derby.impl.sql.GenericActivationHolder

   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to you under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

package org.apache.derby.impl.sql;

import java.sql.SQLWarning;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.derby.catalog.Dependable;
import org.apache.derby.catalog.DependableFinder;
import org.apache.derby.catalog.UUID;
import org.apache.derby.iapi.error.StandardException;
import org.apache.derby.iapi.reference.SQLState; 
import org.apache.derby.iapi.sql.Activation;
import org.apache.derby.iapi.sql.ParameterValueSet;
import org.apache.derby.iapi.sql.ResultDescription;
import org.apache.derby.iapi.sql.ResultSet;
import org.apache.derby.iapi.sql.Row;
import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
import org.apache.derby.iapi.sql.conn.SQLSessionContext; 
import org.apache.derby.iapi.sql.dictionary.TableDescriptor; 
import org.apache.derby.iapi.types.DataTypeDescriptor;
import org.apache.derby.iapi.types.DataValueFactory;
import org.apache.derby.iapi.types.NumberDataValue;
import org.apache.derby.iapi.types.RowLocation; 
import org.apache.derby.shared.common.sanity.SanityManager;

/**
 * This class holds an Activation, and passes through most of the calls to the
 * activation. The purpose of this class is to allow a PreparedStatement to be
 * recompiled without the caller having to detect this and get a new activation.
 *
 * In addition to the Activation, this class holds a reference to the
 * PreparedStatement that created it, along with a reference to the
 * GeneratedClass that was associated with the PreparedStatement at the time
 * this holder was created. These references are used to validate the
 * Activation, to ensure that an activation is used only with the
 * PreparedStatement that created it, and to detect when recompilation has
 * happened.
 *
 * We detect recompilation by checking whether the GeneratedClass has changed.
 * If it has, we try to let the caller continue to use this ActivationHolder. We
 * create a new instance of the new GeneratedClass (that is, we create a new
 * Activation), and we compare the number and type of parameters. If these are
 * compatible, we copy the parameters from the old to the new Activation. If
 * they are not compatible, we throw an exception telling the user that the
 * Activation is out of date, and they need to get a new one.
 *
 */

final public class GenericActivationHolder implements Activation {
 
	DataTypeDescriptor[] paramTypes;
	private final LanguageConnectionContext lcc=null;

	
	  

	/**
	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the
	 * table has a held curosr open at commit time, data should not be deleted
	 * from the table. This method, (gets called at commit time) checks if this
	 * activation held cursor and if so, does that cursor reference the passed
	 * temp table name.
	 *
	 * @return true if this activation has held cursor and if it references the
	 *         passed temp table name
	 */
	public boolean checkIfThisActivationHasHoldCursor(String tableName) {
		return false;
	}

	/**
	 * @see Activation#setCursorName
	 *
	 */
	public void setCursorName(String cursorName) {
		 
	}

	/**
	 * @see Activation#getCursorName
	 */
	public String getCursorName() {
		return "";
	}

	/**
	 * @see Activation#setResultSetHoldability
	 *
	 */
	public void setResultSetHoldability(boolean resultSetHoldability) {
		 
	}

	/**
	 * @see Activation#getResultSetHoldability
	 */
	public boolean getResultSetHoldability() {
		return false;
	}

	/** @see Activation#setAutoGeneratedKeysResultsetInfo */
	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes,
			String[] columnNames) {
	 
	}

	/** @see Activation#getAutoGeneratedKeysResultsetMode */
	public boolean getAutoGeneratedKeysResultsetMode() {
		return false;
	}

	/** @see Activation#getAutoGeneratedKeysColumnIndexes */
	public int[] getAutoGeneratedKeysColumnIndexes() {
		return null;
	}

	/** @see Activation#getAutoGeneratedKeysColumnNames */
	public String[] getAutoGeneratedKeysColumnNames() {
		return null;
	}

	/** @see org.apache.derby.iapi.sql.Activation#getLanguageConnectionContext */
	public LanguageConnectionContext getLanguageConnectionContext() {
		return lcc;
	}

	public void reset(){
		
	}

	/**
	 * @see Activation#getParameterValueSet
	 */
	public ParameterValueSet getParameterValueSet() {
		return null;
	}

	/**
	 * @see Activation#setParameters
	 */
	public void setParameters(ParameterValueSet parameterValues,
			DataTypeDescriptor[] parameterTypes) throws StandardException {
	 
	}

	/**
	 * @see Activation#execute
	 *
	 * @exception StandardException
	 *                Thrown on failure
	 */
	public ResultSet execute() throws StandardException {
		/*
		 * * Synchronize to avoid problems if another thread is preparing* the
		 * statement at the same time we're trying to execute it.
		 */
		// synchronized (ps)
		return null;
	}

	/**
	 * @see Activation#getResultSet
	 *
	 * @return the current ResultSet of this activation.
	 */
	public ResultSet getResultSet() {
		return null;
	}

	 

	/**
	 * @see Activation#getCurrentRow
	 *
	 */
	public Row getCurrentRow(int resultSetNumber) {
		return null;
	}

	/**
	 * @see Activation#clearCurrentRow
	 */
	public void clearCurrentRow(int resultSetNumber) {
		 
	}

	 

	public void checkStatementValidity() throws StandardException {
		 
	}

	/**
	 * @see Activation#getResultDescription
	 */
	public ResultDescription getResultDescription() {
		return  null;
	}

	/**
	 * @see Activation#getDataValueFactory
	 */
	public DataValueFactory getDataValueFactory() {
		return null;
	}

	/**
	 * @see Activation#getRowLocationTemplate
	 */
	public RowLocation getRowLocationTemplate(int itemNumber) {
		return   null;
	}

	 

	 

	/**
	 * @see Activation#clearHeapConglomerateController
	 */
	public void clearHeapConglomerateController() {
		 
	}
 

	 
	/**
	 * @see Activation#getIndexConglomerateNumber
	 */
	public long getIndexConglomerateNumber() {
		return 0;
	}

	/**
	 * @see Activation#setIndexConglomerateNumber
	 */
	public void setIndexConglomerateNumber(long indexConglomerateNumber) {
		 
	}

	/**
	 * @see Activation#clearIndexScanInfo
	 */
	public void clearIndexScanInfo() {
		 
	}

	/**
	 * @see Activation#close
	 *
	 * @exception StandardException
	 *                Thrown on error
	 */
	public void close() throws StandardException {
		 
	}

	/**
	 * @see Activation#isClosed
	 */
	public boolean isClosed() {
		return false;
	}

	/**
	 * Set the activation for a single execution.
	 * 
	 * @see Activation#setSingleExecution
	 */
	public void setSingleExecution() {
		 
	}

	/**
	 * Is the activation set up for a single execution.
	 * 
	 * @see Activation#isSingleExecution
	 */
	public boolean isSingleExecution() {
		return false;
	}

	/**
	 * Get the number of subqueries in the entire query.
	 * 
	 * @return int The number of subqueries in the entire query.
	 */
	public int getNumSubqueries() {
		return 0;
	}

	/**
	 * @see Activation#setForCreateTable()
	 */
	public void setForCreateTable() {
		 
	}

	/**
	 * @see Activation#getForCreateTable()
	 */
	public boolean getForCreateTable() {
		return false;
	}

	/**
	 * @see Activation#setDDLTableDescriptor
	 */
	public void setDDLTableDescriptor(TableDescriptor td) {
	 
	}

	/**
	 * @see Activation#getDDLTableDescriptor
	 */
	public TableDescriptor getDDLTableDescriptor() {
		return null;
	}

	/**
	 * @see Activation#setMaxRows
	 */
	public void setMaxRows(long maxRows) {
		 
	}

	/**
	 * @see Activation#getMaxRows
	 */
	public long getMaxRows() {
		return 0;
	}

	public void setTargetVTI(java.sql.ResultSet targetVTI) {
		 
	}

	public java.sql.ResultSet getTargetVTI() {
		return null;
	}

	public SQLSessionContext getSQLSessionContextForChildren() {
		return null;
	}

	public SQLSessionContext setupSQLSessionContextForChildren(boolean push) {
		return null;
	}

	public void setParentActivation(Activation a) {
		 
	}

	public Activation getParentActivation() {
		return null;
	}

	/* Dependable interface implementation */

	/**
	 * @see Dependable#getDependableFinder
	 */
	public DependableFinder getDependableFinder() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return null;
	}

	/**
	 * @see Dependable#getObjectName
	 */
	public String getObjectName() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return null;
	}

	/**
	 * @see Dependable#getObjectID
	 */
	public UUID getObjectID() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return null;
	}

	/**
	 * @see Dependable#getClassType
	 */
	public String getClassType() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return null;
	}

	/**
	 * @see Dependable#isPersistent
	 */
	public boolean isPersistent() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return false;
	}

	/* Dependent interface implementation */

	/**
	 * @see org.apache.derby.iapi.sql.depend.Dependent#isValid
	 */
	public boolean isValid() {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}

		return false;
	}

	/**
	 * @see org.apache.derby.iapi.sql.depend.Dependent#makeInvalid
	 */
	public void makeInvalid(int action, LanguageConnectionContext lcc)
			throws StandardException {
		// Vacuous implementation to make class concrete, only needed for
		// BaseActivation
		if (SanityManager.DEBUG) {
			SanityManager.NOTREACHED();
		}
	}

 
	/* Class implementation */

	/**
	 * Mark the activation as unused.
	 */
	public void markUnused() {
	 
	}

	/**
	 * Is the activation in use?
	 *
	 * @return true/false
	 */
	public boolean isInUse() {
		return false;
	}

	/**
	 * @see org.apache.derby.iapi.sql.Activation#addWarning
	 */
	public void addWarning(SQLWarning w) {
	 
	}

	/**
	 * @see org.apache.derby.iapi.sql.Activation#getWarnings
	 */
	public SQLWarning getWarnings() {
		return null;
	}

	/**
	 * @see org.apache.derby.iapi.sql.Activation#clearWarnings
	 */
	public void clearWarnings() {
		 
	}

	 
	/**
	 * @see Activation#isCursorActivation
	 */
	public boolean isCursorActivation() {
		return false;
	}

	 
	public void clearParentResultSets() {
		 
	}

	public Enumeration<String> getParentResultSetKeys() {
		return null;
	}

 
	public java.sql.ResultSet[][] getDynamicResults() {
		return null;
	}

	public int getMaxDynamicResults() {
		return 0;
	}

	public NumberDataValue getCurrentValueAndAdvance(String sequenceUUIDstring,
			int typeFormatID) throws StandardException {
		return null;
	}

}
